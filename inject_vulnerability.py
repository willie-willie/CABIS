# -*- coding: utf-8 -*-
"""

@author: Willie
"""

#!/usr/bin/env python3
"""
CABIS CLI - Command Line Interface for Vulnerability Injection
Use this script to inject vulnerabilities into smart contracts
"""

import argparse
import sys
from pathlib import Path
import torch
import json
from typing import Optional

# Add project modules
sys.path.append(str(Path(__file__).parent))

from cabis_implementation import CABIS

def load_contract(file_path: str) -> str:
    """Load contract from file"""
    with open(file_path, 'r') as f:
        return f.read()

def save_contract(contract_code: str, output_path: str):
    """Save contract to file"""
    with open(output_path, 'w') as f:
        f.write(contract_code)

def inject_vulnerability_cli(
    input_file: str,
    output_file: str,
    vuln_type: str,
    model_path: Optional[str] = None,
    ensure_exploitable: bool = True,
    save_metadata: bool = True
):
    """Main CLI function for vulnerability injection"""
    
    print(f"üîß CABIS Vulnerability Injection Tool")
    print(f"{'='*50}")
    
    # Load contract
    print(f"\nüìÑ Loading contract from: {input_file}")
    original_contract = load_contract(input_file)
    print(f"‚úÖ Loaded contract ({len(original_contract)} characters)")
    
    # Initialize CABIS
    print(f"\nü§ñ Initializing CABIS...")
    cabis = CABIS()
    
    # Load trained model if specified
    if model_path:
        print(f"üìÇ Loading model from: {model_path}")
        checkpoint = torch.load(model_path, map_location='cpu')
        # Load model weights (simplified - adjust based on actual checkpoint structure)
        print("‚úÖ Model loaded successfully")
    
    # Inject vulnerability
    print(f"\nüíâ Injecting {vuln_type} vulnerability...")
    result = cabis.inject_vulnerability(
        original_contract,
        vuln_type,
        ensure_exploitable=ensure_exploitable
    )
    
    # Save modified contract
    save_contract(result['modified'], output_file)
    print(f"‚úÖ Modified contract saved to: {output_file}")
    
    # Save metadata if requested
    if save_metadata:
        metadata_file = output_file.replace('.sol', '_metadata.json')
        metadata = {
            'vulnerability_type': vuln_type,
            'injection_points': [
                {
                    'line': point.line_number,
                    'score': point.receptiveness_score
                } for point in result['injection_points']
            ],
            'exploitable': result.get('exploit') is not None,
            'exploit': result.get('exploit')
        }
        
        with open(metadata_file, 'w') as f:
            json.dump(metadata, f, indent=2)
        print(f"üìä Metadata saved to: {metadata_file}")
    
    # Print summary
    print(f"\n{'='*50}")
    print(f"‚úÖ Vulnerability Injection Complete!")
    print(f"   Type: {vuln_type}")
    print(f"   Injection Points: {len(result['injection_points'])}")
    print(f"   Exploitable: {'Yes' if result.get('exploit') else 'Unknown'}")
    
    if result.get('exploit'):
        print(f"\nüéØ Exploit:")
        print(f"   {result['exploit']}")

def batch_inject(
    input_dir: str,
    output_dir: str,
    vuln_type: str,
    model_path: Optional[str] = None
):
    """Batch inject vulnerabilities into multiple contracts"""
    input_path = Path(input_dir)
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    sol_files = list(input_path.glob("*.sol"))
    print(f"\nüóÇÔ∏è  Found {len(sol_files)} Solidity files")
    
    success_count = 0
    for i, sol_file in enumerate(sol_files, 1):
        print(f"\n[{i}/{len(sol_files)}] Processing {sol_file.name}")
        
        try:
            output_file = output_path / f"{sol_file.stem}_vuln_{vuln_type}.sol"
            inject_vulnerability_cli(
                str(sol_file),
                str(output_file),
                vuln_type,
                model_path,
                ensure_exploitable=False,  # Faster for batch
                save_metadata=True
            )
            success_count += 1
        except Exception as e:
            print(f"‚ùå Error processing {sol_file.name}: {str(e)}")
    
    print(f"\n‚úÖ Batch injection complete: {success_count}/{len(sol_files)} successful")

def main():
    parser = argparse.ArgumentParser(
        description='CABIS - Context-Aware Bug Injection System CLI',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # Inject reentrancy vulnerability into a single contract
  python inject_vulnerability.py -i contract.sol -o contract_vuln.sol -v reentrancy
  
  # Inject timestamp dependence with custom model
  python inject_vulnerability.py -i contract.sol -o output.sol -v timestamp_dependence -m models/cabis_best.pt
  
  # Batch inject vulnerabilities
  python inject_vulnerability.py --batch -i contracts/ -o vulnerable/ -v unchecked_call

Supported vulnerability types:
  - reentrancy
  - timestamp_dependence
  - integer_overflow
  - unchecked_call
  - delegatecall
  - tx_origin
  - uninitialized_storage
  - arbitrary_send
  - self_destruct
  - locked_ether
        '''
    )
    
    parser.add_argument('-i', '--input', required=True,
                       help='Input Solidity file or directory (for batch mode)')
    parser.add_argument('-o', '--output', required=True,
                       help='Output Solidity file or directory (for batch mode)')
    parser.add_argument('-v', '--vulnerability', required=True,
                       choices=['reentrancy', 'timestamp_dependence', 'integer_overflow',
                               'unchecked_call', 'delegatecall', 'tx_origin',
                               'uninitialized_storage', 'arbitrary_send', 'self_destruct',
                               'locked_ether'],
                       help='Type of vulnerability to inject')
    parser.add_argument('-m', '--model', default=None,
                       help='Path to trained CABIS model checkpoint')
    parser.add_argument('--batch', action='store_true',
                       help='Batch mode - process multiple files')
    parser.add_argument('--no-exploit', action='store_true',
                       help='Skip exploitability verification (faster)')
    parser.add_argument('--no-metadata', action='store_true',
                       help='Do not save metadata file')
    
    args = parser.parse_args()
    
    if args.batch:
        batch_inject(
            args.input,
            args.output,
            args.vulnerability,
            args.model
        )
    else:
        inject_vulnerability_cli(
            args.input,
            args.output,
            args.vulnerability,
            args.model,
            ensure_exploitable=not args.no_exploit,
            save_metadata=not args.no_metadata
        )

if __name__ == "__main__":
    main()